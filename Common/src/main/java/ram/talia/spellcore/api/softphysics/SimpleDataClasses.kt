package ram.talia.spellcore.api.softphysics

import net.minecraft.world.phys.Vec3
import ram.talia.spellcore.api.div
import ram.talia.spellcore.api.minus
import ram.talia.spellcore.api.plus
import ram.talia.spellcore.api.times
import kotlin.math.PI
import kotlin.math.atan2


data class Vertex(var pos: Vec3, var vel: Vec3, val mass: Double) {
    var force: Vec3 = Vec3.ZERO

    operator fun plus(other: Vertex): Vec3 = this.pos + other.pos
    operator fun minus(other: Vertex): Vec3 = this.pos - other.pos

    fun applyForce(dT: Double) {
        // TODO RK4
        val acc = force / mass
        vel += acc * dT
        pos += vel * dT - (acc * dT * dT / 2.0)
        force = Vec3.ZERO
    }
}

typealias EdgeKey = Pair<Vertex, Vertex>

data class Edge(val p0: Vertex, val p1: Vertex, val restLength: Double) {
    fun toKey(): EdgeKey = p0 to p1
}

data class Face(val p0: Vertex, val p1: Vertex, val p2: Vertex) {
    fun edges(): List<EdgeKey> = mutableListOf(p0 to p1, p1 to p2, p2 to p0)

    fun normal(): Vec3 = (p2 - p0).cross(p1 - p0).normalize()

    /**
     * Given an edge, return the vertex of this face not on that edge.
     */
    fun otherPoint(edge: EdgeKey): Vertex {
        return when (edge) {
            p0 to p1 -> p2
            p1 to p0 -> p2
            p1 to p2 -> p0
            p2 to p1 -> p0
            p2 to p0 -> p1
            p0 to p2 -> p1
            else -> { throw IllegalArgumentException("$edge was not one of the edges of $this") }
        }
    }

    fun inverse(): Face = Face(p2, p1, p0)

    fun angleTo(other: Face, sharedEdge: EdgeKey): Double {
//        assert(p0 == sharedEdge.first && p1 == sharedEdge.second ||
//                p1 == sharedEdge.first && p2 == sharedEdge.second ||
//                p2 == sharedEdge.first && p0 == sharedEdge.second)

        // TODO: figure out if this is necessary.
        val alignedSharedEdge = if (sharedEdge in this.edges()) sharedEdge else (sharedEdge.second to sharedEdge.first)

        val edgeVec = (alignedSharedEdge.second - alignedSharedEdge.first).normalize()
        val edgeMid = 0.5 * (alignedSharedEdge.second + alignedSharedEdge.first)

        // a point on the plane of this face, forming a vector with the shared edge perpendicular to it
        val thisPointIntermediary = edgeVec.cross(this.normal())
        val thisPoint = (this.otherPoint(sharedEdge).pos - edgeMid).dot(thisPointIntermediary).times(thisPointIntermediary).normalize()
        val otherPointIntermediary = edgeVec.cross(this.normal())
        val otherPoint = (other.otherPoint(sharedEdge).pos - edgeMid).dot(otherPointIntermediary).times(otherPointIntermediary).normalize()

        val dot = thisPoint.dot(otherPoint)
        val det = edgeVec.dot(thisPoint.cross(otherPoint))

        return atan2(det, dot).let { if (it >= 0) it else it + 2*PI }
    }

    override fun equals(other: Any?): Boolean {
        return other != null &&
                other is Face && ((
                        other.p0 == this.p0 &&
                        other.p1 == this.p1 &&
                        other.p2 == this.p2
                    ) || (
                        other.p0 == this.p1 &&
                        other.p1 == this.p2 &&
                        other.p2 == this.p0
                    ) || (
                        other.p0 == this.p2 &&
                        other.p1 == this.p0 &&
                        other.p2 == this.p1
                    )
                )
    }

    override fun hashCode(): Int {
        return p0.hashCode() + p1.hashCode() + p2.hashCode()
    }
}

data class Shape private constructor(val faces: List<Face>) : List<Face> by faces {
    /**
     * Pass a list of [Face]s, and the map of [EdgeKey]s to list of faces generated by calling [Physics.comupteFacesByEdge] on that list of faces,
     * returns the shape containing that list of faces if [areConnected] is true, and null otherwise. (also returns null if the list of faces is empty.)
     */
    fun makeShape(faces: List<Face>, facesByEdge: Map<EdgeKey, List<Face>>): Shape? {
        return if (faces.isNotEmpty() && areConnected(faces, facesByEdge)) Shape(faces) else null
    }

    companion object {
        /**
         * Pass a list of [Face]s, and the map of [EdgeKey]s to list of faces generated by calling [Physics.comupteFacesByEdge] on that list of faces,
         * and returns whether all of those faces can be reached by traversing the surface of the shape.
         */
        fun areConnected(faces: List<Face>, facesByEdge: Map<EdgeKey, List<Face>>): Boolean {
            val undiscoveredFaces = faces.toMutableSet()

            val toExplore = mutableListOf(faces.first())

            while (toExplore.isNotEmpty()) {
                val currentFace = toExplore.removeFirst()

                // find all faces adjacent to the current face that haven't been explored yet, remove them from undiscoveredFaces and add them to toExplore.
                for (edge in currentFace.edges()) {
                    val toAdd = facesByEdge[edge]?.intersect(undiscoveredFaces) ?: throw IllegalArgumentException("facesByEdge didn't contain entry for edge $edge of face $currentFace")
                    undiscoveredFaces.removeAll(toAdd)
                    toExplore.addAll(toAdd)
                }

                if (undiscoveredFaces.isEmpty())
                    return true
            }

            // can only reach this point if the exploration from the first face has run out of new faces to discover, and there are still undiscovered faces.
            return false
        }
    }
}

data class Volume(val adjacentShapes: List<Shape>, var volume: Double, var mass: Double, var temperature: Double)